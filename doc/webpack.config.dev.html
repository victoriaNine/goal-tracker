<!DOCTYPE html><html lang="en"><head><title>webpack.config.dev</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="webpack.config.dev"><meta name="groc-project-path" content="webpack.config.dev.js"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">webpack.config.dev.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="configuration-webpack-de-dev">Configuration Webpack de dev</h1></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> autoprefixer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'autoprefixer'</span>)
<span class="hljs-keyword">var</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>)
<span class="hljs-keyword">var</span> OfflinePlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'offline-plugin'</span>)
<span class="hljs-keyword">var</span> Path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">var</span> shared = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.config.shared'</span>)
<span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Le dossier de sortie &quot;théorique&quot; (en dev, Webpack va en fait
tout traiter en mémoire, pour une meilleure réactivité lors
du <em>watch</em>)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> outputFolder = Path.resolve(__dirname, <span class="hljs-string">'public'</span>)

<span class="hljs-built_in">module</span>.exports = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="points-dentre">Points d’entrée</h2>
<p>Les &quot;sommets&quot; de l’arborescence de dépendances de l’appli.
En d’autre termes, les points d’entrée de l’application.</p>
<p>On a ici une seule entry (même si c’est un tableau), donc un seul
<em>bundle</em> en sortie.  Mais <code>entry</code> pourrait être un objet dont les
clés seraient les noms de bundles, et les valeurs les descriptifs
de contenus.</p></div></div><div class="code"><div class="wrapper">  entry: {
    app: [</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On a besoin du polyfill de Babel pour la gestion des fonctions <code>async</code>,
vu qu&#39;on prend en charge des navigateurs variés…</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-string">'babel-polyfill'</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>En dev, on utilise le <a href="https://webpack.github.io/docs/hot-module-replacement.html">HMR</a>,
ce qui nécessite un petit morceau de JS «client» dans le bundle
exécuté au sein du navigateur.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-string">'webpack-hot-middleware/client'</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Et par ailleurs, on a le point d’entrée de notre application
proprement dite.</p></div></div><div class="code"><div class="wrapper">      Path.resolve(__dirname, <span class="hljs-string">'src/index.js'</span>)
    ]
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="fichiers-en-sortie">Fichiers en sortie</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">  output: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Le chemin de base pour les fichiers (bundles, etc.) à produire
lors d’un <em>build</em> (en dev, tout sera en mémoire, mais pour un
<em>build</em> on pondra bien les fichiers).</p></div></div><div class="code"><div class="wrapper">    path: outputFolder,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>L’URL publique associée à ce chemin sur le disque, ce qui permet
d’ajuster les URLs produites en interne par Webpack.  Ici, la
racine du domaine.</p></div></div><div class="code"><div class="wrapper">    publicPath: <span class="hljs-string">'/'</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Le nom du bundle (ou si on a plusieurs bundles,
le schéma de nommage).</p></div></div><div class="code"><div class="wrapper">    filename: <span class="hljs-string">'[name].js'</span>
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="plugins">Plugins</h2>
<p>Les plugins indiquent des ajustements au traitement de fichiers
par Webpack, le plus souvent <em>a posteriori</em> mais parfois au fil
des transformations.</p></div></div><div class="code"><div class="wrapper">  plugins: [</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Copie / met à dispo en mémoire des fichiers statiques vers un
chemin en sortie.  On aurait pu les coller direct dans <code>public/</code>,
mais alors Webpack ne les aurait pas «détectés», et d’autres
plugins ne les auraient pas pris en compte (tels que la gestion
de l’<em>offline</em>, par exemple).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">new</span> CopyWebpackPlugin([{
      from: <span class="hljs-string">'static'</span>,
      to: outputFolder
    }]),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>La deuxième partie du HMR, le côté serveur.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On évite que des erreurs Webpack (fichiers manquants, etc.)
plantent complètement le serveur: on se contente de les afficher
sur la console et on attend que ça change pour ré-essayer.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">new</span> webpack.NoEmitOnErrorsPlugin(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extraction automatique des modules npm dans un bundle à part, <code>vendor.js</code>.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin({
      name: <span class="hljs-string">'vendor'</span>,
      minChunks: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">module</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.context &amp;&amp; <span class="hljs-built_in">module</span>.context.indexOf(<span class="hljs-string">'node_modules'</span>) !== -<span class="hljs-number">1</span>
      }
    }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Super plugin de traitement <em>a posteriori</em> qui génère et maintient
pour nous les fichiers nécessaires à un fonctionnement <em>offline-first</em>:
source de ServiceWorker (<code>sw.js</code>) et solution de secours basée
Application Cache (dossier <code>appcache</code>).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">new</span> OfflinePlugin(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Configuration PostCSS : on utilisera ici un traitement <a href="https://github.com/postcss/autoprefixer#readme">Autoprefixer</a>
par défaut, parce qu’on n’est plus en 2010…</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">new</span> webpack.LoaderOptionsPlugin({
      options: {
        postcss: [autoprefixer()]
      }
    })
  ],
  <span class="hljs-built_in">module</span>: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="chargeurs-de-syntaxe">Chargeurs de syntaxe</h2>
<p>C’est le cœur de Webpack: les chargeurs de syntaxe qui nous
permettent, depuis notre JS, de déclarer nos dépendances à des
<em>assets</em> quelconques (CSS, images, fontes…) via les mécanismes
habituels d’<code>import</code>/<code>require</code>.</p></div></div><div class="code"><div class="wrapper">    rules: [
      {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Toute dépendance aboutissant à un fichier <code>.js</code> sera
d’abord «moulinée» par Babel.  En revanche, on fout la paix au
contenu de <code>node_modules</code>, qui n’a pas vocation à être
transpilé.</p></div></div><div class="code"><div class="wrapper">        test: <span class="hljs-regexp">/\.js$/</span>,
        exclude: <span class="hljs-regexp">/node_modules/</span>,
        use: { loader: <span class="hljs-string">'babel-loader'</span>, options: shared.getAdjustedBabelOptions() }
      },
      {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Toute dépendance CSS pure (<code>.css</code>) passera par la trinité
classique: PostCSS pour l’auto-préfixage et autres
<em>post-processings</em>, CSS pour la transformation en objets
descriptifs et Style pour l’injection live dans la page.
Notez que dans une chaîne de <em>loaders</em> exprimée comme ça
(<code>String</code> avec des <code>!</code> en séparateurs), les <em>loaders</em> sont
en fait exploités de droite à gauche.</p></div></div><div class="code"><div class="wrapper">        test: <span class="hljs-regexp">/\.css$/</span>,
        use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'postcss-loader'</span>]
      },
      {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Nos propres styles sont en <a href="http://stylus-lang.com/">Stylus</a>,
donc on utilise la même chaîne de traitement que pour les
CSS pures, mais avec la transpilation Stylus -&gt; CSS d’abord.</p></div></div><div class="code"><div class="wrapper">        test: <span class="hljs-regexp">/\.styl$/</span>,
        use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'postcss-loader'</span>, <span class="hljs-string">'stylus-loader'</span>]
      },
      {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On a recours à plusieurs images (en fait, que des PNG pour
notre app, mais soyons inclusifs…), on utilisera donc le
URL Loader, une spécialisation du File Loader.  Ici, si
le fichier pèse moins de 10000 octets, il produira une URL
<em>inline</em> (&quot;Data URI&quot;), économisant ainsi une requête réseau
côté client.  Dans le cas contraire, il produira bien une
URL normale vers un fichier.</p></div></div><div class="code"><div class="wrapper">        test: <span class="hljs-regexp">/\.(jpe?g|png|gif)$/</span>,
        use: { loader: <span class="hljs-string">'url-loader'</span>, options: { limit: <span class="hljs-number">10000</span> } }
      }
    ]
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="source-maps">Source Maps</h2>
<p>Webpack nous propose une bonne demi-douzaine de types de
<a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source maps</a>
pour nos fichiers transpilés et le bundle final, mais seules
certaines garantissent le bon fonctionnement des points
d’arrêt dans Chrome.  On utilise ici celle qui, parmi les «bonnes»,
est créée le plus vite par Webpack.</p></div></div><div class="code"><div class="wrapper">  devtool: <span class="hljs-string">'#inline-source-map'</span>
}</div></div></div></div></body></html>